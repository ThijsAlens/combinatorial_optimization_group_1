{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eab24eaa",
   "metadata": {},
   "outputs": [],
   "source": [
    "from dataclasses import dataclass\n",
    "from typing import List, Optional\n",
    "\n",
    "@dataclass\n",
    "class TOPTWNode:\n",
    "    i: int\n",
    "    x: float\n",
    "    y: float\n",
    "    service: float    # service duration\n",
    "    profit: float     # profit / score\n",
    "    tw_open: float    # earliest service time\n",
    "    tw_close: float   # latest service time\n",
    "    f: int            # extra field from original format\n",
    "    a: int            # length of aux_list in original file\n",
    "    aux_list: List[int]\n",
    "    demand: int = 0   # NEW: demand of this node (0 for depot)\n",
    "\n",
    "@dataclass\n",
    "class TOPTWInstance:\n",
    "    path: str\n",
    "    k: int            # number of vehicles / routes allowed\n",
    "    v: int            # carried over from source format\n",
    "    N: int            # number of customers (excl. depot)\n",
    "    t: int            # carried over from source format\n",
    "    D: Optional[float]\n",
    "    Q: Optional[float]   # vehicle capacity we'll assign\n",
    "    Tmax: float          # usually depot.tw_close in source data\n",
    "    nodes: List[TOPTWNode]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "00f331d7",
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "import pathlib\n",
    "import re\n",
    "from typing import Tuple\n",
    "\n",
    "def _floor_to_decimals(x: float, decimals: int) -> float:\n",
    "    if decimals is None:\n",
    "        return float(x)\n",
    "    f = 10 ** decimals\n",
    "    return math.floor(x * f) / f\n",
    "\n",
    "def _auto_rounding_decimals_from_name(path: str) -> int:\n",
    "    # c101, r201, rc2xx -> Solomon (1 decimal); else Cordeau (2 decimals)\n",
    "    name = pathlib.Path(path).name.lower()\n",
    "    if re.search(r'(?:^|_)((c|r|rc)\\d+)', name):\n",
    "        return 1\n",
    "    return 2\n",
    "\n",
    "def build_distance_time_matrices(inst: TOPTWInstance,\n",
    "                                 speed: float = 1.0,\n",
    "                                 rounding: str = \"auto\"  # \"auto\"|\"solomon\"|\"cordeau\"|\"none\"\n",
    "                                 ) -> Tuple[List[List[float]], List[List[float]]]:\n",
    "    pts = [(n.x, n.y) for n in inst.nodes]\n",
    "    n = len(pts)\n",
    "    if rounding == \"auto\":\n",
    "        dec = _auto_rounding_decimals_from_name(inst.path)\n",
    "    elif rounding == \"solomon\":\n",
    "        dec = 1\n",
    "    elif rounding == \"cordeau\":\n",
    "        dec = 2\n",
    "    else:\n",
    "        dec = None\n",
    "\n",
    "    def euclid(a, b): return math.hypot(a[0]-b[0], a[1]-b[1])\n",
    "\n",
    "    dist = [[0.0]*n for _ in range(n)]\n",
    "    tmat = [[0.0]*n for _ in range(n)]\n",
    "    for i in range(n):\n",
    "        for j in range(n):\n",
    "            if i == j:\n",
    "                d = 0.0\n",
    "            else:\n",
    "                d = euclid(pts[i], pts[j])\n",
    "                d = _floor_to_decimals(d, dec)\n",
    "            dist[i][j] = d\n",
    "            tmat[i][j] = d / speed if speed > 0 else d\n",
    "    return dist, tmat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "543a6965",
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "\n",
    "def load_capacitated_instance(json_path: str) -> TOPTWInstance:\n",
    "    \"\"\"Load a JSON file created by convert_to_capacitated_json back into TOPTWInstance.\"\"\"\n",
    "    with open(json_path, \"r\") as f:\n",
    "        data = json.load(f)\n",
    "\n",
    "    nodes: List[TOPTWNode] = []\n",
    "    for nd in data[\"nodes\"]:\n",
    "        nodes.append(\n",
    "            TOPTWNode(\n",
    "                i=nd[\"i\"],\n",
    "                x=nd[\"x\"],\n",
    "                y=nd[\"y\"],\n",
    "                service=nd[\"service\"],\n",
    "                profit=nd[\"profit\"],\n",
    "                tw_open=nd[\"tw_open\"],\n",
    "                tw_close=nd[\"tw_close\"],\n",
    "                f=nd[\"f\"],\n",
    "                a=nd[\"a\"],\n",
    "                aux_list=nd[\"aux_list\"],\n",
    "                demand=nd.get(\"demand\",0),\n",
    "            )\n",
    "        )\n",
    "\n",
    "    inst = TOPTWInstance(\n",
    "        path=data.get(\"name\", json_path),\n",
    "        k=data[\"k\"],\n",
    "        v=data[\"v\"],\n",
    "        N=data[\"N\"],\n",
    "        t=data[\"t\"],\n",
    "        D=data[\"D\"],\n",
    "        Q=data[\"Q\"],\n",
    "        Tmax=data[\"Tmax\"],\n",
    "        nodes=nodes,\n",
    "    )\n",
    "    return inst\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0e98582e",
   "metadata": {},
   "outputs": [],
   "source": [
    "from dataclasses import dataclass\n",
    "from typing import List, Tuple, Optional\n",
    "import heapq\n",
    "import numpy as np\n",
    "\n",
    "@dataclass\n",
    "class Route:\n",
    "    \"\"\"One vehicle route: list of node indices (0 = depot)\"\"\"\n",
    "    nodes: List[int]          # e.g. [0, 5, 12, 0]\n",
    "    load: int = 0\n",
    "    time: float = 0.0         # arrival time at the *last* node (before returning)\n",
    "    profit: float = 0.0\n",
    "    cost: float = 0.0         # travel distance cost of the route (excluding fixed cost)\n",
    "\n",
    "    def copy(self) -> \"Route\":\n",
    "        return Route(nodes=self.nodes[:], load=self.load,\n",
    "                     time=self.time, profit=self.profit, cost=self.cost)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dc75d377",
   "metadata": {},
   "outputs": [],
   "source": [
    "def can_insert(inst: TOPTWInstance, dist: List[List[float]], tmat: List[List[float]],\n",
    "               route: Route, pos: int, cust: int,\n",
    "               hard_tw: bool = True, beta: float = 0.0) -> Tuple[bool, float, float]:\n",
    "    \"\"\"\n",
    "    Check if customer `cust` can be inserted at position `pos` in `route`.\n",
    "    Returns (feasible, new_load, new_arrival_at_cust, new_route_time, lateness_at_cust)\n",
    "    \"\"\"\n",
    "    n = len(route.nodes)\n",
    "    if pos == 0 or pos == n:               # cannot insert before start or after end\n",
    "        return False, 0, 0, 0, 0\n",
    "\n",
    "    prev = route.nodes[pos-1]\n",
    "    nxt  = route.nodes[pos]\n",
    "\n",
    "    # ----- capacity -----\n",
    "    new_load = route.load + inst.nodes[cust].demand\n",
    "    if new_load > inst.Q:\n",
    "        return False, 0, 0, 0, 0\n",
    "\n",
    "    # ----- time -----\n",
    "    arrival_prev = route.time if pos == 1 else \\\n",
    "        route.time + inst.nodes[prev].service + tmat[prev][cust]\n",
    "\n",
    "    # earliest possible start of service at cust\n",
    "    earliest = max(arrival_prev, inst.nodes[cust].tw_open)\n",
    "\n",
    "    if hard_tw and earliest > inst.nodes[cust].tw_close:\n",
    "        return False, 0, 0, 0, 0\n",
    "\n",
    "    # service start (wait if we arrive early)\n",
    "    start_service = earliest\n",
    "    lateness = 0.0\n",
    "    if not hard_tw:\n",
    "        if start_service > inst.nodes[cust].tw_close:\n",
    "            lateness = start_service - inst.nodes[cust].tw_close\n",
    "            start_service = start_service   # we still serve at arrival time\n",
    "\n",
    "    # departure from cust\n",
    "    departure = start_service + inst.nodes[cust].service\n",
    "\n",
    "    # time to next node\n",
    "    arrival_next = departure + tmat[cust][nxt]\n",
    "\n",
    "    # check TW of the *next* node (must shift its start time)\n",
    "    nxt_node = inst.nodes[nxt]\n",
    "    earliest_next = max(arrival_next, nxt_node.tw_open)\n",
    "    if hard_tw and earliest_next > nxt_node.tw_close:\n",
    "        return False, 0, 0, 0, 0\n",
    "\n",
    "    # new route time = arrival at the node *after* the inserted one\n",
    "    new_route_time = arrival_next + nxt_node.service   # ready to leave nxt\n",
    "\n",
    "    # optional global route duration limit\n",
    "    if inst.Tmax is not None:\n",
    "        return_time = new_route_time + tmat[nxt][0]   # back to depot\n",
    "        if return_time > inst.Tmax + 1e-6:\n",
    "            return False, 0, 0, 0, 0\n",
    "\n",
    "    return True, new_load, start_service, new_route_time, lateness"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dc13cdba",
   "metadata": {},
   "outputs": [],
   "source": [
    "def greedy_profit_density(inst: TOPTWInstance,\n",
    "                         dist: List[List[float]],\n",
    "                         tmat: List[List[float]],\n",
    "                         K: int,\n",
    "                         hard_tw: bool = True,\n",
    "                         f: float = 0.0,\n",
    "                         beta: float = 0.0) -> List[Route]:\n",
    "    \"\"\"\n",
    "    Classic greedy: at each step insert the customer with highest\n",
    "    p_i / (d_0i + s_i) into the *cheapest* feasible position of any route.\n",
    "    \"\"\"\n",
    "    unvisited = set(range(1, inst.N+1))\n",
    "    routes: List[Route] = [Route(nodes=[0, 0]) for _ in range(K)]  # empty routes\n",
    "\n",
    "    def density(c):\n",
    "        node = inst.nodes[c]\n",
    "        d0 = dist[0][c]\n",
    "        return node.profit / (d0 + node.service + 1e-9)\n",
    "\n",
    "    while unvisited:\n",
    "        # 1. candidate with best density\n",
    "        best_c = max(unvisited, key=density, default=None)\n",
    "        if best_c is None:\n",
    "            break\n",
    "\n",
    "        inserted = False\n",
    "        best_route_idx = -1\n",
    "        best_pos = -1\n",
    "        best_extra_cost = np.inf\n",
    "\n",
    "        for r_idx, route in enumerate(routes):\n",
    "            # try every possible slot (between two consecutive nodes)\n",
    "            for pos in range(1, len(route.nodes)):\n",
    "                feasible, new_load, _, new_time, lateness = can_insert(\n",
    "                    inst, dist, tmat, route, pos, best_c, hard_tw, beta)\n",
    "\n",
    "                if not feasible:\n",
    "                    continue\n",
    "\n",
    "                # extra travel cost of the insertion\n",
    "                prev = route.nodes[pos-1]\n",
    "                nxt  = route.nodes[pos]\n",
    "                old_cost = dist[prev][nxt]\n",
    "                new_cost = dist[prev][best_c] + dist[best_c][nxt]\n",
    "                extra = new_cost - old_cost\n",
    "\n",
    "                if extra < best_extra_cost:\n",
    "                    best_extra_cost = extra\n",
    "                    best_route_idx = r_idx\n",
    "                    best_pos = pos\n",
    "\n",
    "        if best_route_idx == -1:                     # cannot insert anywhere\n",
    "            unvisited.remove(best_c)\n",
    "            continue\n",
    "\n",
    "        # ----- perform insertion -----\n",
    "        r = routes[best_route_idx]\n",
    "        cnode = inst.nodes[best_c]\n",
    "        r.nodes.insert(best_pos, best_c)\n",
    "        r.load += cnode.demand\n",
    "        r.profit += cnode.profit\n",
    "        r.cost += best_extra_cost\n",
    "        # update arrival time at the node *after* insertion\n",
    "        _, _, _, new_time, _ = can_insert(inst, dist, tmat, r, best_pos+1, best_c,\n",
    "                                          hard_tw, beta)\n",
    "        r.time = new_time\n",
    "\n",
    "        unvisited.remove(best_c)\n",
    "\n",
    "    # remove completely empty routes (they cost a fixed fee if f>0)\n",
    "    \n",
    "    routes = [r for r in routes if len(r.nodes) > 2]\n",
    "    return routes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c52aa96",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate_solution(inst: TOPTWInstance,\n",
    "                      routes: List[Route],\n",
    "                      dist: List[List[float]],\n",
    "                      f: float = 0.0,\n",
    "                      beta: float = 0.0,\n",
    "                      hard_tw: bool = True,\n",
    "                      alpha: float = 0.1) -> float:\n",
    "    \"\"\"\n",
    "    Returns the *objective value* (to be maximised):\n",
    "        Σ profit – α * Σ distance – f * #vehicles – β * Σ lateness\n",
    "    \n",
    "    Args:\n",
    "        alpha: Distance weight. Typical values:\n",
    "               - 0.01: profit outweighs distance 100:1\n",
    "               - 0.1:  profit outweighs distance 10:1  (DEFAULT)\n",
    "               - 0.5:  profit outweighs distance 2:1\n",
    "    \"\"\"\n",
    "    total_profit = sum(r.profit for r in routes)\n",
    "    total_dist   = sum(r.cost for r in routes)\n",
    "    n_veh        = len(routes)\n",
    "    lateness     = 0.0\n",
    "\n",
    "    if not hard_tw:                     # recompute lateness for soft-TW\n",
    "        for r in routes:\n",
    "            cur_time = 0.0\n",
    "            for i in range(1, len(r.nodes)-1):\n",
    "                prev = r.nodes[i-1]\n",
    "                cur  = r.nodes[i]\n",
    "                cur_time = max(cur_time + inst.nodes[prev].service + dist[prev][cur],\n",
    "                               inst.nodes[cur].tw_open)\n",
    "                if cur_time > inst.nodes[cur].tw_close:\n",
    "                    lateness += cur_time - inst.nodes[cur].tw_close\n",
    "                cur_time += inst.nodes[cur].service\n",
    "\n",
    "    return total_profit - alpha * total_dist - f * n_veh - beta * lateness"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "efa03907",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import copy\n",
    "from typing import List, Tuple, Optional, Dict\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from dataclasses import dataclass, field\n",
    "\n",
    "# Assumes your existing Route, TOPTWInstance, and helper functions are already defined\n",
    "\n",
    "@dataclass\n",
    "class SearchMetrics:\n",
    "    \"\"\"Track local search performance\"\"\"\n",
    "    iteration: int = 0\n",
    "    objective_history: List[float] = field(default_factory=list)\n",
    "    time_history: List[float] = field(default_factory=list)\n",
    "    operator_counts: Dict[str, int] = field(default_factory=lambda: {\n",
    "        'insert': 0, 'relocate': 0, 'swap': 0, '2opt': 0\n",
    "    })\n",
    "    improvement_counts: Dict[str, int] = field(default_factory=lambda: {\n",
    "        'insert': 0, 'relocate': 0, 'swap': 0, '2opt': 0\n",
    "    })\n",
    "    customers_served_history: List[int] = field(default_factory=list)\n",
    "    \n",
    "    def log_iteration(self, obj: float, elapsed: float, customers: int):\n",
    "        self.iteration += 1\n",
    "        self.objective_history.append(obj)\n",
    "        self.time_history.append(elapsed)\n",
    "        self.customers_served_history.append(customers)\n",
    "\n",
    "\n",
    "class LocalSearch:\n",
    "    def __init__(self, inst: TOPTWInstance, dist: List[List[float]], \n",
    "                 tmat: List[List[float]], hard_tw: bool = True, \n",
    "                 f: float = 0.0, beta: float = 0.0, alpha: float = 0.1, seed: int = 42):\n",
    "        self.inst = inst\n",
    "        self.dist = dist\n",
    "        self.tmat = tmat\n",
    "        self.hard_tw = hard_tw\n",
    "        self.f = f\n",
    "        self.beta = beta\n",
    "        self.alpha = alpha  # Distance weight (profit weight is implicitly 1.0)\n",
    "        self.rng = np.random.default_rng(seed)\n",
    "        self.metrics = SearchMetrics()\n",
    "        \n",
    "    def copy_solution(self, routes: List[Route]) -> List[Route]:\n",
    "        \"\"\"Deep copy of solution\"\"\"\n",
    "        return [r.copy() for r in routes]\n",
    "    \n",
    "    def get_unvisited(self, routes: List[Route]) -> set:\n",
    "        \"\"\"Get set of unvisited customers\"\"\"\n",
    "        visited = set()\n",
    "        for r in routes:\n",
    "            visited.update(r.nodes[1:-1])  # exclude depot\n",
    "        return set(range(1, self.inst.N + 1)) - visited\n",
    "    \n",
    "    def recalculate_route_metrics(self, route: Route):\n",
    "        \"\"\"Recalculate load, cost, time, and profit for a route\"\"\"\n",
    "        route.load = sum(self.inst.nodes[c].demand for c in route.nodes[1:-1])\n",
    "        route.profit = sum(self.inst.nodes[c].profit for c in route.nodes[1:-1])\n",
    "        \n",
    "        # Calculate cost (distance)\n",
    "        route.cost = 0.0\n",
    "        for i in range(len(route.nodes) - 1):\n",
    "            route.cost += self.dist[route.nodes[i]][route.nodes[i+1]]\n",
    "        \n",
    "        # Calculate time (arrival at last customer before depot)\n",
    "        route.time = 0.0\n",
    "        for i in range(1, len(route.nodes) - 1):\n",
    "            prev = route.nodes[i-1]\n",
    "            curr = route.nodes[i]\n",
    "            route.time = max(route.time + self.inst.nodes[prev].service + self.tmat[prev][curr],\n",
    "                           self.inst.nodes[curr].tw_open)\n",
    "            if i == len(route.nodes) - 2:  # last customer\n",
    "                route.time += self.inst.nodes[curr].service\n",
    "    \n",
    "    def is_route_feasible(self, route: Route) -> bool:\n",
    "        \"\"\"Check if route satisfies capacity and time window constraints\"\"\"\n",
    "        # Check capacity\n",
    "        if route.load > self.inst.Q:\n",
    "            return False\n",
    "        \n",
    "        # Check time windows\n",
    "        current_time = 0.0\n",
    "        for i in range(1, len(route.nodes)):\n",
    "            prev = route.nodes[i-1]\n",
    "            curr = route.nodes[i]\n",
    "            \n",
    "            # Travel time + service at previous\n",
    "            current_time += self.inst.nodes[prev].service + self.tmat[prev][curr]\n",
    "            \n",
    "            # Wait if arriving early\n",
    "            current_time = max(current_time, self.inst.nodes[curr].tw_open)\n",
    "            \n",
    "            # Check if too late\n",
    "            if current_time > self.inst.nodes[curr].tw_close + 1e-6:\n",
    "                return False\n",
    "        \n",
    "        # Check route duration (time to return to depot)\n",
    "        if self.inst.Tmax is not None:\n",
    "            if current_time > self.inst.Tmax + 1e-6:\n",
    "                return False\n",
    "        \n",
    "        return True\n",
    "    \n",
    "    # ==================== NEIGHBORHOOD OPERATORS ====================\n",
    "    \n",
    "    def try_insert(self, routes: List[Route], current_obj: float) -> Tuple[bool, List[Route], str, float]:\n",
    "        \"\"\"Insert operator: find BEST insertion of unvisited customer\n",
    "        Returns: (feasible, best_routes, message, delta_obj)\n",
    "        \"\"\"\n",
    "        unvisited = self.get_unvisited(routes)\n",
    "        if not unvisited:\n",
    "            return False, routes, \"\", 0.0\n",
    "        \n",
    "        best_routes = None\n",
    "        best_delta = 0.0\n",
    "        best_message = \"\"\n",
    "        \n",
    "        for customer in unvisited:\n",
    "            for r_idx in range(len(routes)):\n",
    "                route = routes[r_idx]\n",
    "                # Try all positions in route\n",
    "                for pos in range(1, len(route.nodes)):\n",
    "                    new_route = route.copy()\n",
    "                    new_route.nodes.insert(pos, customer)\n",
    "                    self.recalculate_route_metrics(new_route)\n",
    "                    \n",
    "                    if self.is_route_feasible(new_route):\n",
    "                        new_routes = self.copy_solution(routes)\n",
    "                        new_routes[r_idx] = new_route\n",
    "                        new_obj = evaluate_solution(self.inst, new_routes, self.dist, \n",
    "                                                   self.f, self.beta, self.hard_tw, self.alpha)\n",
    "                        \n",
    "                        delta = new_obj - current_obj\n",
    "                        if delta > best_delta + 1e-6:\n",
    "                            best_delta = delta\n",
    "                            best_routes = new_routes\n",
    "                            best_message = f\"INSERT: Added customer {customer} to route {r_idx} at position {pos} (Δ={delta:.2f})\"\n",
    "        \n",
    "        if best_routes is not None:\n",
    "            return True, best_routes, best_message, best_delta\n",
    "        return False, routes, \"\", 0.0\n",
    "    \n",
    "    def try_relocate(self, routes: List[Route], current_obj: float) -> Tuple[bool, List[Route], str, float]:\n",
    "        \"\"\"Relocate operator: find BEST relocation of a customer\n",
    "        Returns: (feasible, best_routes, message, delta_obj)\n",
    "        \"\"\"\n",
    "        best_routes = None\n",
    "        best_delta = 0.0\n",
    "        best_message = \"\"\n",
    "        \n",
    "        for r1_idx in range(len(routes)):\n",
    "            route1 = routes[r1_idx]\n",
    "            if len(route1.nodes) <= 2:  # Empty route\n",
    "                continue\n",
    "            \n",
    "            for cust_pos in range(1, len(route1.nodes) - 1):\n",
    "                customer = route1.nodes[cust_pos]\n",
    "                \n",
    "                # Try inserting into all routes (including same route)\n",
    "                for r2_idx in range(len(routes)):\n",
    "                    route2 = routes[r2_idx]\n",
    "                    \n",
    "                    for insert_pos in range(1, len(route2.nodes)):\n",
    "                        # Skip if same position in same route\n",
    "                        if r1_idx == r2_idx and insert_pos == cust_pos:\n",
    "                            continue\n",
    "                        \n",
    "                        # Create new routes\n",
    "                        new_route1 = route1.copy()\n",
    "                        new_route1.nodes.pop(cust_pos)\n",
    "                        self.recalculate_route_metrics(new_route1)\n",
    "                        \n",
    "                        new_route2 = route2.copy()\n",
    "                        # Adjust insert position if same route and removing before insertion\n",
    "                        adj_insert_pos = insert_pos\n",
    "                        if r1_idx == r2_idx and cust_pos < insert_pos:\n",
    "                            adj_insert_pos -= 1\n",
    "                        new_route2.nodes.insert(adj_insert_pos, customer)\n",
    "                        self.recalculate_route_metrics(new_route2)\n",
    "                        \n",
    "                        if self.is_route_feasible(new_route1) and self.is_route_feasible(new_route2):\n",
    "                            new_routes = self.copy_solution(routes)\n",
    "                            new_routes[r1_idx] = new_route1\n",
    "                            if r1_idx != r2_idx:\n",
    "                                new_routes[r2_idx] = new_route2\n",
    "                            else:\n",
    "                                new_routes[r1_idx] = new_route2\n",
    "                            \n",
    "                            new_obj = evaluate_solution(self.inst, new_routes, self.dist, \n",
    "                                                       self.f, self.beta, self.hard_tw, self.alpha)\n",
    "                            \n",
    "                            delta = new_obj - current_obj\n",
    "                            if delta > best_delta + 1e-6:\n",
    "                                best_delta = delta\n",
    "                                best_routes = new_routes\n",
    "                                best_message = f\"RELOCATE: Moved customer {customer} from route {r1_idx} to route {r2_idx} (Δ={delta:.2f})\"\n",
    "        \n",
    "        if best_routes is not None:\n",
    "            return True, best_routes, best_message, best_delta\n",
    "        return False, routes, \"\", 0.0\n",
    "    \n",
    "    def try_swap(self, routes: List[Route], current_obj: float) -> Tuple[bool, List[Route], str, float]:\n",
    "        \"\"\"Swap operator: find BEST swap of two customers between different routes\n",
    "        Returns: (feasible, best_routes, message, delta_obj)\n",
    "        \"\"\"\n",
    "        if len(routes) < 2:\n",
    "            return False, routes, \"\", 0.0\n",
    "        \n",
    "        best_routes = None\n",
    "        best_delta = 0.0\n",
    "        best_message = \"\"\n",
    "        \n",
    "        for r1_idx in range(len(routes)):\n",
    "            for r2_idx in range(r1_idx + 1, len(routes)):\n",
    "                route1, route2 = routes[r1_idx], routes[r2_idx]\n",
    "                \n",
    "                if len(route1.nodes) <= 2 or len(route2.nodes) <= 2:\n",
    "                    continue\n",
    "                \n",
    "                for pos1 in range(1, len(route1.nodes) - 1):\n",
    "                    for pos2 in range(1, len(route2.nodes) - 1):\n",
    "                        cust1 = route1.nodes[pos1]\n",
    "                        cust2 = route2.nodes[pos2]\n",
    "                        \n",
    "                        # Create new routes with swap\n",
    "                        new_route1 = route1.copy()\n",
    "                        new_route1.nodes[pos1] = cust2\n",
    "                        self.recalculate_route_metrics(new_route1)\n",
    "                        \n",
    "                        new_route2 = route2.copy()\n",
    "                        new_route2.nodes[pos2] = cust1\n",
    "                        self.recalculate_route_metrics(new_route2)\n",
    "                        \n",
    "                        if self.is_route_feasible(new_route1) and self.is_route_feasible(new_route2):\n",
    "                            new_routes = self.copy_solution(routes)\n",
    "                            new_routes[r1_idx] = new_route1\n",
    "                            new_routes[r2_idx] = new_route2\n",
    "                            new_obj = evaluate_solution(self.inst, new_routes, self.dist, \n",
    "                                                       self.f, self.beta, self.hard_tw, self.alpha)\n",
    "                            \n",
    "                            delta = new_obj - current_obj\n",
    "                            if delta > best_delta + 1e-6:\n",
    "                                best_delta = delta\n",
    "                                best_routes = new_routes\n",
    "                                best_message = f\"SWAP: Exchanged customer {cust1} (route {r1_idx}) with {cust2} (route {r2_idx}) (Δ={delta:.2f})\"\n",
    "        \n",
    "        if best_routes is not None:\n",
    "            return True, best_routes, best_message, best_delta\n",
    "        return False, routes, \"\", 0.0\n",
    "    \n",
    "    def try_2opt(self, routes: List[Route], current_obj: float) -> Tuple[bool, List[Route], str, float]:\n",
    "        \"\"\"2-opt operator: find BEST segment reversal within a single route\n",
    "        Returns: (feasible, best_routes, message, delta_obj)\n",
    "        \"\"\"\n",
    "        best_routes = None\n",
    "        best_delta = 0.0\n",
    "        best_message = \"\"\n",
    "        \n",
    "        for r_idx in range(len(routes)):\n",
    "            route = routes[r_idx]\n",
    "            n = len(route.nodes)\n",
    "            \n",
    "            if n <= 3:  # Need at least 2 customers to reverse\n",
    "                continue\n",
    "            \n",
    "            # Try all possible segment reversals\n",
    "            for i in range(1, n - 1):\n",
    "                for j in range(i + 1, n - 1):\n",
    "                    # Reverse segment between i and j (inclusive)\n",
    "                    new_route = route.copy()\n",
    "                    new_route.nodes[i:j+1] = reversed(new_route.nodes[i:j+1])\n",
    "                    self.recalculate_route_metrics(new_route)\n",
    "                    \n",
    "                    if self.is_route_feasible(new_route):\n",
    "                        new_routes = self.copy_solution(routes)\n",
    "                        new_routes[r_idx] = new_route\n",
    "                        new_obj = evaluate_solution(self.inst, new_routes, self.dist, \n",
    "                                                   self.f, self.beta, self.hard_tw, self.alpha)\n",
    "                        \n",
    "                        delta = new_obj - current_obj\n",
    "                        if delta > best_delta + 1e-6:\n",
    "                            best_delta = delta\n",
    "                            best_routes = new_routes\n",
    "                            best_message = f\"2OPT: Reversed segment [{i},{j}] in route {r_idx} (Δ={delta:.2f})\"\n",
    "        \n",
    "        if best_routes is not None:\n",
    "            return True, best_routes, best_message, best_delta\n",
    "        return False, routes, \"\", 0.0\n",
    "    \n",
    "    # ==================== MAIN SEARCH ====================\n",
    "    \n",
    "    def search(self, initial_routes: List[Route], max_time: float = 120.0, \n",
    "               strategy: str = 'best', \n",
    "               operator_set: Tuple[str, ...] = ('insert', 'relocate', 'swap', '2opt'),\n",
    "               shuffle_operators: bool = True,\n",
    "               verbose: bool = True) -> Tuple[List[Route], SearchMetrics]:\n",
    "        \"\"\"\n",
    "        Main local search.\n",
    "        \n",
    "        Args:\n",
    "            initial_routes: The starting solution\n",
    "            max_time: Time limit in seconds\n",
    "            strategy: 'best' (Best-Improvement) or 'first' (First-Improvement)\n",
    "            operator_set: Tuple of operator names (strings) to use.\n",
    "            shuffle_operators: Whether to shuffle the operator list each iteration.\n",
    "            verbose: Print logs\n",
    "        \"\"\"\n",
    "        if strategy not in ['best', 'first']:\n",
    "            raise ValueError(\"Strategy must be 'best' or 'first'\")\n",
    "            \n",
    "        routes = self.copy_solution(initial_routes)\n",
    "        start_time = time.time()\n",
    "        \n",
    "        # Log initial solution\n",
    "        initial_obj = evaluate_solution(self.inst, routes, self.dist, self.f, self.beta, self.hard_tw, self.alpha)\n",
    "        initial_customers = sum(len(r.nodes) - 2 for r in routes)\n",
    "        self.metrics.log_iteration(initial_obj, 0.0, initial_customers)\n",
    "        \n",
    "        if verbose:\n",
    "            print(f\"{'='*70}\")\n",
    "            print(f\"LOCAL SEARCH STARTED (STRATEGY: {strategy.upper()})\")\n",
    "            print(f\"{'='*70}\")\n",
    "            print(f\"Operators: {operator_set}\")\n",
    "            print(f\"Shuffle: {shuffle_operators}\")\n",
    "            print(f\"Initial objective: {initial_obj:.2f}\")\n",
    "            print(f\"Max time: {max_time}s\")\n",
    "            print(f\"{'='*70}\\n\")\n",
    "        \n",
    "        # Define all *possible* operators\n",
    "        all_operators = {\n",
    "            'insert': self.try_insert,\n",
    "            'relocate': self.try_relocate,\n",
    "            'swap': self.try_swap,\n",
    "            '2opt': self.try_2opt\n",
    "        }\n",
    "        \n",
    "        # --- Filter operators based on the hyperparameter ---\n",
    "        # This is the list of (name, function) tuples we will actually use\n",
    "        operators_to_use = []\n",
    "        for op_name in operator_set:\n",
    "            if op_name in all_operators:\n",
    "                operators_to_use.append((op_name, all_operators[op_name]))\n",
    "                # Initialize counts for operators we are actually using\n",
    "                if op_name not in self.metrics.operator_counts:\n",
    "                    self.metrics.operator_counts[op_name] = 0\n",
    "                if op_name not in self.metrics.improvement_counts:\n",
    "                    self.metrics.improvement_counts[op_name] = 0\n",
    "            else:\n",
    "                print(f\"Warning: Unknown operator '{op_name}' ignored.\")\n",
    "        \n",
    "        improvement_found = True\n",
    "        iteration = 0\n",
    "        \n",
    "        while improvement_found:\n",
    "            improvement_found = False\n",
    "            elapsed = time.time() - start_time\n",
    "            \n",
    "            # Check time limit\n",
    "            if elapsed >= max_time:\n",
    "                if verbose:\n",
    "                    print(f\"\\n{'='*70}\\nTIME LIMIT REACHED ({max_time}s)\\n{'='*70}\")\n",
    "                break\n",
    "            \n",
    "            current_obj = evaluate_solution(self.inst, routes, self.dist, \n",
    "                                            self.f, self.beta, self.hard_tw, self.alpha)\n",
    "            \n",
    "            # --- STRATEGY-DEPENDENT LOGIC ---\n",
    "            \n",
    "            best_new_routes = None\n",
    "            best_delta = 0.0\n",
    "            best_operator = None\n",
    "            best_message = \"\"\n",
    "\n",
    "            # --- Use shuffle hyperparameter ---\n",
    "            if shuffle_operators:\n",
    "                self.rng.shuffle(operators_to_use) \n",
    "            \n",
    "            for op_name, op_func in operators_to_use: # Use the filtered list\n",
    "                self.metrics.operator_counts[op_name] += 1\n",
    "                \n",
    "                if verbose and iteration % 5 == 0:\n",
    "                    print(f\"   Evaluating {op_name.upper()} neighborhood...\", end='\\r')\n",
    "                \n",
    "                improved, new_routes, message, delta = op_func(routes, current_obj)\n",
    "                \n",
    "                if improved:\n",
    "                    if strategy == 'best':\n",
    "                        # BI: Find the best move across ALL operators\n",
    "                        if delta > best_delta + 1e-6:\n",
    "                            best_delta = delta\n",
    "                            best_new_routes = new_routes\n",
    "                            best_operator = op_name\n",
    "                            best_message = message\n",
    "                    \n",
    "                    elif strategy == 'first':\n",
    "                        # FI: Take the first improving move we find\n",
    "                        # (which is the *best* from this *one* neighborhood)\n",
    "                        best_delta = delta\n",
    "                        best_new_routes = new_routes\n",
    "                        best_operator = op_name\n",
    "                        best_message = message\n",
    "                        improvement_found = True  # Mark improvement\n",
    "                        break # <-- Key difference: break operator loop\n",
    "                \n",
    "                if time.time() - start_time >= max_time:\n",
    "                    break # Break operator loop if time's up\n",
    "            \n",
    "            # --- END STRATEGY LOGIC ---\n",
    "\n",
    "            # Apply best move\n",
    "            # For 'best' strategy, this applies the best move found (if any)\n",
    "            # For 'first' strategy, this applies the first improving move found\n",
    "            if best_new_routes is not None:\n",
    "                routes = best_new_routes\n",
    "                self.metrics.improvement_counts[best_operator] += 1\n",
    "                improvement_found = True\n",
    "                iteration += 1\n",
    "                \n",
    "                # Log metrics\n",
    "                new_obj = evaluate_solution(self.inst, routes, self.dist, \n",
    "                                            self.f, self.beta, self.hard_tw, self.alpha)\n",
    "                current_customers = sum(len(r.nodes) - 2 for r in routes)\n",
    "                elapsed = time.time() - start_time\n",
    "                self.metrics.log_iteration(new_obj, elapsed, current_customers)\n",
    "                \n",
    "                if verbose:\n",
    "                    print(f\"Iter {iteration:4d} | Time: {elapsed:6.2f}s | Obj: {new_obj:8.2f} | \"\n",
    "                          f\"Customers: {current_customers:3d} | {best_message}\")\n",
    "\n",
    "        # Final statistics\n",
    "        final_obj = evaluate_solution(self.inst, routes, self.dist, self.f, self.beta, self.hard_tw, self.alpha)\n",
    "        final_customers = sum(len(r.nodes) - 2 for r in routes)\n",
    "        total_time = time.time() - start_time\n",
    "        \n",
    "        if verbose:\n",
    "            print(f\"\\n{'='*70}\\nLOCAL SEARCH COMPLETED\\n{'='*70}\")\n",
    "            print(f\"Total iterations: {iteration}\")\n",
    "            print(f\"Total time: {total_time:.2f}s\")\n",
    "            print(f\"Final objective: {final_obj:.2f}\")\n",
    "            if initial_obj != 0:\n",
    "                print(f\"Improvement: {final_obj - initial_obj:.2f} ({((final_obj/initial_obj - 1)*100):.1f}%)\")\n",
    "            else:\n",
    "                print(f\"Improvement: {final_obj - initial_obj:.2f}\")\n",
    "            print(f\"Final customers served: {final_customers}/{self.inst.N}\")\n",
    "            print(f\"\\nOperator statistics:\")\n",
    "            \n",
    "            for op_name in operator_set:\n",
    "                imp_count = self.metrics.improvement_counts.get(op_name, 0)\n",
    "                att_count = self.metrics.operator_counts.get(op_name, 0)\n",
    "                print(f\"  {op_name.upper():<8}: {imp_count:4d} improvements / {att_count:5d} evaluations\")\n",
    "            print(f\"{'='*70}\\n\")\n",
    "            \n",
    "        return routes, self.metrics\n",
    "\n",
    "\n",
    "# ==================== VISUALIZATION ====================\n",
    "\n",
    "def plot_search_progress(metrics: SearchMetrics, instance_name: str = \"\"):\n",
    "    \"\"\"Create comprehensive visualization of search progress\"\"\"\n",
    "    fig, axes = plt.subplots(2, 2, figsize=(14, 10))\n",
    "    fig.suptitle(f'Local Search Progress: {instance_name}', fontsize=14, fontweight='bold')\n",
    "    \n",
    "    # Plot 1: Objective value over time\n",
    "    ax1 = axes[0, 0]\n",
    "    ax1.plot(metrics.time_history, metrics.objective_history, 'b-', linewidth=2)\n",
    "    ax1.set_xlabel('Time (seconds)', fontsize=10)\n",
    "    ax1.set_ylabel('Objective Value', fontsize=10)\n",
    "    ax1.set_title('Objective Value Over Time', fontsize=11)\n",
    "    ax1.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Add improvement annotation\n",
    "    if len(metrics.objective_history) > 1:\n",
    "        improvement = metrics.objective_history[-1] - metrics.objective_history[0]\n",
    "        pct_improvement = (improvement / metrics.objective_history[0]) * 100 if metrics.objective_history[0] != 0 else 0\n",
    "        ax1.text(0.02, 0.98, f'Improvement: {improvement:.1f} ({pct_improvement:.1f}%)', \n",
    "                transform=ax1.transAxes, fontsize=9, verticalalignment='top',\n",
    "                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n",
    "    \n",
    "    # Plot 2: Objective value over iterations\n",
    "    ax2 = axes[0, 1]\n",
    "    ax2.plot(range(len(metrics.objective_history)), metrics.objective_history, 'g-', linewidth=2)\n",
    "    ax2.set_xlabel('Iteration', fontsize=10)\n",
    "    ax2.set_ylabel('Objective Value', fontsize=10)\n",
    "    ax2.set_title('Objective Value Over Iterations', fontsize=11)\n",
    "    ax2.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 3: Customers served over time\n",
    "    ax3 = axes[1, 0]\n",
    "    ax3.plot(metrics.time_history, metrics.customers_served_history, 'r-', linewidth=2)\n",
    "    ax3.set_xlabel('Time (seconds)', fontsize=10)\n",
    "    ax3.set_ylabel('Customers Served', fontsize=10)\n",
    "    ax3.set_title('Customers Served Over Time', fontsize=11)\n",
    "    ax3.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 4: Operator effectiveness\n",
    "    ax4 = axes[1, 1]\n",
    "    operators = list(metrics.improvement_counts.keys())\n",
    "    improvements = [metrics.improvement_counts[op] for op in operators]\n",
    "    attempts = [metrics.operator_counts[op] for op in operators]\n",
    "    \n",
    "    x = np.arange(len(operators))\n",
    "    width = 0.35\n",
    "    \n",
    "    bars1 = ax4.bar(x - width/2, attempts, width, label='Attempts', alpha=0.7)\n",
    "    bars2 = ax4.bar(x + width/2, improvements, width, label='Improvements', alpha=0.7)\n",
    "    \n",
    "    ax4.set_xlabel('Operator', fontsize=10)\n",
    "    ax4.set_ylabel('Count', fontsize=10)\n",
    "    ax4.set_title('Operator Statistics', fontsize=11)\n",
    "    ax4.set_xticks(x)\n",
    "    ax4.set_xticklabels([op.upper() for op in operators], fontsize=9)\n",
    "    ax4.legend(fontsize=9)\n",
    "    ax4.grid(True, alpha=0.3, axis='y')\n",
    "    \n",
    "    # Add success rate text\n",
    "    for i, (op, att, imp) in enumerate(zip(operators, attempts, improvements)):\n",
    "        success_rate = (imp / att * 100) if att > 0 else 0\n",
    "        ax4.text(i, max(att, imp) * 1.05, f'{success_rate:.1f}%', \n",
    "                ha='center', fontsize=8)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    return fig"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "sa-class-cell",
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "import random\n",
    "\n",
    "# NEW CLASS: Simulated Annealing\n",
    "# This class inherits from LocalSearch to reuse all its helper methods\n",
    "# (recalculate_route_metrics, is_route_feasible, get_unvisited, etc.)\n",
    "\n",
    "class SimulatedAnnealing(LocalSearch):\n",
    "    \n",
    "    def __init__(self, inst: TOPTWInstance, dist: List[List[float]], \n",
    "                 tmat: List[List[float]], hard_tw: bool = True, \n",
    "                 f: float = 0.0, beta: float = 0.0, alpha: float = 0.1, seed: int = 42):\n",
    "        # Initialize the parent class (LocalSearch)\n",
    "        # This sets up self.inst, self.dist, self.rng, self.metrics, etc.\n",
    "        super().__init__(inst, dist, tmat, hard_tw, f, beta, alpha, seed)\n",
    "\n",
    "    # ==================== RANDOM NEIGHBORHOOD OPERATORS ====================\n",
    "    # These functions generate ONE random, feasible neighbor, unlike the \n",
    "    # LocalSearch operators which found the BEST neighbor.\n",
    "\n",
    "    def _get_random_insert(self, routes: List[Route]) -> Optional[List[Route]]:\n",
    "        \"\"\"Try to find one random, feasible insertion move.\"\"\"\n",
    "        unvisited = self.get_unvisited(routes)\n",
    "        if not unvisited:\n",
    "            return None\n",
    "        \n",
    "        customer = self.rng.choice(list(unvisited))\n",
    "        r_idx = self.rng.integers(0, len(routes))\n",
    "        route = routes[r_idx]\n",
    "        \n",
    "        # Need at least [0, 0] to insert into\n",
    "        if len(route.nodes) < 2:\n",
    "            return None # Should not happen with [0,0] routes\n",
    "            \n",
    "        pos = self.rng.integers(1, len(route.nodes)) # e.g., for [0, 0], pos=1\n",
    "        \n",
    "        new_route = route.copy()\n",
    "        new_route.nodes.insert(pos, customer)\n",
    "        self.recalculate_route_metrics(new_route)\n",
    "        \n",
    "        if self.is_route_feasible(new_route):\n",
    "            new_routes = self.copy_solution(routes)\n",
    "            new_routes[r_idx] = new_route\n",
    "            return new_routes\n",
    "            \n",
    "        return None # Failed this random attempt\n",
    "\n",
    "    def _get_random_relocate(self, routes: List[Route]) -> Optional[List[Route]]:\n",
    "        \"\"\"Try to find one random, feasible relocate move.\"\"\"\n",
    "        # Find routes with at least one customer\n",
    "        valid_r1_indices = [i for i, r in enumerate(routes) if len(r.nodes) > 2]\n",
    "        if not valid_r1_indices:\n",
    "            return None\n",
    "\n",
    "        r1_idx = self.rng.choice(valid_r1_indices)\n",
    "        route1 = routes[r1_idx]\n",
    "        \n",
    "        cust_pos = self.rng.integers(1, len(route1.nodes) - 1)\n",
    "        customer = route1.nodes[cust_pos]\n",
    "        \n",
    "        r2_idx = self.rng.integers(0, len(routes))\n",
    "        route2 = routes[r2_idx]\n",
    "        \n",
    "        insert_pos = self.rng.integers(1, len(route2.nodes)) # e.g. for [0,0] -> pos=1\n",
    "        \n",
    "        # Create new routes\n",
    "        new_route1 = route1.copy()\n",
    "        new_route1.nodes.pop(cust_pos)\n",
    "        self.recalculate_route_metrics(new_route1)\n",
    "        \n",
    "        new_route2 = route2.copy()\n",
    "        adj_insert_pos = insert_pos\n",
    "        if r1_idx == r2_idx and cust_pos < insert_pos:\n",
    "            adj_insert_pos -= 1\n",
    "        \n",
    "        new_route2.nodes.insert(adj_insert_pos, customer)\n",
    "        self.recalculate_route_metrics(new_route2)\n",
    "        \n",
    "        if self.is_route_feasible(new_route1) and self.is_route_feasible(new_route2):\n",
    "            new_routes = self.copy_solution(routes)\n",
    "            new_routes[r1_idx] = new_route1\n",
    "            new_routes[r2_idx] = new_route2\n",
    "            return new_routes\n",
    "            \n",
    "        return None # Failed this random attempt\n",
    "\n",
    "    def _get_random_swap(self, routes: List[Route]) -> Optional[List[Route]]:\n",
    "        \"\"\"Try to find one random, feasible swap move (inter-route only).\"\"\"\n",
    "        valid_r_indices = [i for i, r in enumerate(routes) if len(r.nodes) > 2]\n",
    "        if len(valid_r_indices) < 2:\n",
    "            return None # Need two different routes with customers\n",
    "\n",
    "        r1_idx, r2_idx = self.rng.choice(valid_r_indices, 2, replace=False)\n",
    "        route1, route2 = routes[r1_idx], routes[r2_idx]\n",
    "        \n",
    "        pos1 = self.rng.integers(1, len(route1.nodes) - 1)\n",
    "        pos2 = self.rng.integers(1, len(route2.nodes) - 1)\n",
    "        cust1, cust2 = route1.nodes[pos1], route2.nodes[pos2]\n",
    "        \n",
    "        new_route1 = route1.copy()\n",
    "        new_route1.nodes[pos1] = cust2\n",
    "        self.recalculate_route_metrics(new_route1)\n",
    "        \n",
    "        new_route2 = route2.copy()\n",
    "        new_route2.nodes[pos2] = cust1\n",
    "        self.recalculate_route_metrics(new_route2)\n",
    "        \n",
    "        if self.is_route_feasible(new_route1) and self.is_route_feasible(new_route2):\n",
    "            new_routes = self.copy_solution(routes)\n",
    "            new_routes[r1_idx] = new_route1\n",
    "            new_routes[r2_idx] = new_route2\n",
    "            return new_routes\n",
    "            \n",
    "        return None # Failed this random attempt\n",
    "\n",
    "    def _get_random_2opt(self, routes: List[Route]) -> Optional[List[Route]]:\n",
    "        \"\"\"Try to find one random, feasible 2-opt move (intra-route).\"\"\"\n",
    "        # Need at least 2 customers (4 nodes) to perform 2-opt\n",
    "        valid_r_indices = [i for i, r in enumerate(routes) if len(r.nodes) > 3]\n",
    "        if not valid_r_indices:\n",
    "            return None\n",
    "            \n",
    "        r_idx = self.rng.choice(valid_r_indices)\n",
    "        route = routes[r_idx]\n",
    "        n = len(route.nodes)\n",
    "        \n",
    "        # i is first break, j is second break.\n",
    "        # i from 1 to n-3 (inclusive)\n",
    "        # j from i+1 to n-2 (inclusive)\n",
    "        # e.g. [0, 1, 2, 3, 0], n=5\n",
    "        # i in [1, 2]. \n",
    "        #   if i=1, j in [2, 3]. \n",
    "        #     j=2: reverse [1, 2] -> [0, 2, 1, 3, 0]\n",
    "        #     j=3: reverse [1, 2, 3] -> [0, 3, 2, 1, 0]\n",
    "        #   if i=2, j in [3, 3].\n",
    "        #     j=3: reverse [2, 3] -> [0, 1, 3, 2, 0]\n",
    "        \n",
    "        i = self.rng.integers(1, n - 2)\n",
    "        j = self.rng.integers(i + 1, n - 1)\n",
    "\n",
    "        new_route = route.copy()\n",
    "        new_route.nodes[i:j+1] = reversed(new_route.nodes[i:j+1])\n",
    "        self.recalculate_route_metrics(new_route)\n",
    "        \n",
    "        if self.is_route_feasible(new_route):\n",
    "            new_routes = self.copy_solution(routes)\n",
    "            new_routes[r_idx] = new_route\n",
    "            return new_routes\n",
    "            \n",
    "        return None # Failed this random attempt\n",
    "\n",
    "    def get_random_neighbor(self, routes: List[Route], \n",
    "                            operator_set: Tuple[str, ...]) -> Tuple[Optional[List[Route]], Optional[str]]:\n",
    "        \"\"\"\n",
    "        Picks a random operator and tries to generate one random, feasible neighbor.\n",
    "        Tries all operators in a random order until one succeeds.\n",
    "        \"\"\"\n",
    "        all_operators = {\n",
    "            'insert': self._get_random_insert,\n",
    "            'relocate': self._get_random_relocate,\n",
    "            'swap': self._get_random_swap,\n",
    "            '2opt': self._get_random_2opt\n",
    "        }\n",
    "        \n",
    "        # Use only the operators specified in the set\n",
    "        ops_to_use = [op for op in operator_set if op in all_operators]\n",
    "        self.rng.shuffle(ops_to_use) # Randomize operator order\n",
    "\n",
    "        for op_name in ops_to_use:\n",
    "            op_func = all_operators[op_name]\n",
    "            new_routes = op_func(routes)\n",
    "            \n",
    "            if new_routes is not None:\n",
    "                # Found a feasible neighbor\n",
    "                return new_routes, op_name\n",
    "                \n",
    "        return None, None # No feasible neighbor found\n",
    "\n",
    "    # ==================== MAIN SA SEARCH ====================\n",
    "    \n",
    "    def search(self, \n",
    "               initial_routes: List[Route], \n",
    "               max_time: float = 120.0,\n",
    "               operator_set: Tuple[str, ...] = ('insert', 'relocate', 'swap', '2opt'),\n",
    "               T_start: float = 100.0,\n",
    "               T_end: float = 0.01,\n",
    "               alpha_cooling: float = 0.99,\n",
    "               max_iter_per_temp: int = 200,\n",
    "               verbose: bool = True) -> Tuple[List[Route], SearchMetrics]:\n",
    "        \"\"\"\n",
    "        Main Simulated Annealing search.\n",
    "        \"\"\"\n",
    "        start_time = time.time()\n",
    "        \n",
    "        # --- 1. Initialization ---\n",
    "        current_routes = self.copy_solution(initial_routes)\n",
    "        current_obj = evaluate_solution(self.inst, current_routes, self.dist, \n",
    "                                        self.f, self.beta, self.hard_tw, self.alpha)\n",
    "        \n",
    "        best_routes = self.copy_solution(current_routes)\n",
    "        best_obj = current_obj\n",
    "        \n",
    "        T = T_start\n",
    "        iteration = 0\n",
    "        \n",
    "        # Log initial solution\n",
    "        initial_customers = sum(len(r.nodes) - 2 for r in current_routes)\n",
    "        self.metrics.log_iteration(current_obj, 0.0, initial_customers)\n",
    "        \n",
    "        if verbose:\n",
    "            print(f\"\\n{'='*70}\")\n",
    "            print(f\"SIMULATED ANNEALING STARTED\")\n",
    "            print(f\"{'-'*70}\")\n",
    "            print(f"Operators: {operator_set}")\n",
    "            print(f"Params: T_start={T_start}, T_end={T_end}, alpha={alpha_cooling}, iter/temp={max_iter_per_temp}")\n",
    "            print(f"Initial objective: {initial_obj:.2f} | Max time: {max_time}s")\n",
    "            print(f"{'='*70}\\n")\n",
    "        \n",
    "        # --- 2. Main SA Loop ---\n",
    "        while T > T_end:\n",
    "            elapsed = time.time() - start_time\n",
    "            if elapsed >= max_time:\n",
    "                if verbose:\n",
    "                    print(f\"\\n{'='*70}\\nTIME LIMIT REACHED ({max_time}s)\\n{'='*70}\")\n",
    "                break\n",
    "            \n",
    "            if verbose:\n",
    "                print(f\"--- Temp: {T:8.3f} | Iterations for this temp: {max_iter_per_temp} ---\", end='\\r')\n",
    "\n",
    "            iter_at_temp = 0\n",
    "            while iter_at_temp < max_iter_per_temp:\n",
    "                iter_at_temp += 1\n",
    "                iteration += 1\n",
    "                \n",
    "                # Check time limit inside inner loop\n",
    "                if time.time() - start_time >= max_time:\n",
    "                    break\n",
    "                \n",
    "                # --- 2a. Generate Neighbor ---\n",
    "                new_routes, op_name = self.get_random_neighbor(current_routes, operator_set)\n",
    "                \n",
    "                if new_routes is None:\n",
    "                    continue # No feasible neighbor found, try again\n",
    "                \n",
    "                self.metrics.operator_counts[op_name] += 1\n",
    "                \n",
    "                # --- 2b. Evaluate Neighbor ---\n",
    "                new_obj = evaluate_solution(self.inst, new_routes, self.dist,\n",
    "                                            self.f, self.beta, self.hard_tw, self.alpha)\n",
    "                \n",
    "                delta_obj = new_obj - current_obj\n",
    "                \n",
    "                # --- 2c. Acceptance Criterion ---\n",
    "                accepted = False\n",
    "                if delta_obj > 0:\n",
    "                    # Always accept improvements\n",
    "                    accepted = True\n",
    "                    self.metrics.improvement_counts[op_name] += 1\n",
    "                else:\n",
    "                    # Accept worse solutions with probability\n",
    "                    acceptance_prob = math.exp(delta_obj / T)\n",
    "                    if self.rng.random() < acceptance_prob:\n",
    "                        accepted = True\n",
    "                \n",
    "                # --- 2d. Update Solution ---\n",
    "                if accepted:\n",
    "                    current_routes = new_routes\n",
    "                    current_obj = new_obj\n",
    "                    \n",
    "                    # Log this accepted move\n",
    "                    elapsed = time.time() - start_time\n",
    "                    customers = sum(len(r.nodes) - 2 for r in current_routes)\n",
    "                    self.metrics.log_iteration(current_obj, elapsed, customers)\n",
    "                    \n",
    "                    # Update best-so-far\n",
    "                    if current_obj > best_obj:\n",
    "                        best_routes = self.copy_solution(current_routes)\n",
    "                        best_obj = current_obj\n",
    "                        if verbose:\n",
    "                            print(f\"Iter {iteration:5d} | Time: {elapsed:6.2f}s | NEW BEST: {best_obj:8.2f} | \"\n",
    "                                  f\"Temp: {T:7.2f} | Move: {op_name.upper()}\")\n",
    "                \n",
    "                if verbose and iteration % 200 == 0 and not (accepted and delta_obj > 0):\n",
    "                    print(f\"Iter {iteration:5d} | Time: {elapsed:6.2f}s | Obj: {current_obj:8.2f} | \"\n",
    "                          f\"Best: {best_obj:8.2f} | Temp: {T:7.2f}\")\n",
    "\n",
    "            # --- 2e. Cool Temperature ---\n",
    "            T *= alpha_cooling\n",
    "\n",
    "        # --- 3. Final Statistics ---\n",
    "        final_obj = best_obj\n",
    "        final_customers = sum(len(r.nodes) - 2 for r in best_routes)\n",
    "        total_time = time.time() - start_time\n",
    "        \n",
    "        if verbose:\n",
    "            print(f\"\\n{'='*70}\\nSIMULATED ANNEALING COMPLETED\\n{'='*70}\")\n",
    "            print(f\"Total iterations: {iteration}\")\n",
    "            print(f\"Total time: {total_time:.2f}s\")\n",
    "            print(f\"Final objective: {final_obj:.2f}\")\n",
    "            if initial_obj != 0:\n",
    "                print(f\"Improvement: {final_obj - initial_obj:.2f} ({((final_obj/initial_obj - 1)*100):.1f}%)\")\n",
    "            else:\n",
    "                print(f\"Improvement: {final_obj - initial_obj:.2f}\")\n",
    "            print(f\"Final customers served: {final_customers}/{self.inst.N}\")\n",
    "            print(f\"\\nOperator statistics (Successful moves):\")\n",
    "            \n",
    "            for op_name in operator_set:\n",
    "                imp_count = self.metrics.improvement_counts.get(op_name, 0)\n",
    "                att_count = self.metrics.operator_counts.get(op_name, 0)\n",
    "                print(f\"  {op_name.upper():<8}: {imp_count:4d} improvements / {att_count:5d} evaluations\")\n",
    "            print(f\"{'='*70}\\n\")\n",
    "            \n",
    "        return best_routes, self.metrics\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ac72a88e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ==================== DEMO USAGE ====================\n",
    "\n",
    "# MODIFIED for Simulated Annealing\n",
    "\n",
    "def run_sa_experiment(json_path: str, K_modifier: int = 0, seed: int = 42, \n",
    "                      max_time: float = 60.0, alpha: float = 0.1, \n",
    "                      operator_set: Tuple[str, ...] = ('insert', 'relocate', 'swap', '2opt'),\n",
    "                      T_start: float = 100.0,\n",
    "                      T_end: float = 0.01,\n",
    "                      alpha_cooling: float = 0.99,\n",
    "                      max_iter_per_temp: int = 200,\n",
    "                      verbose: bool = False, plot: bool = False):\n",
    "    \"\"\"\n",
    "    Complete experiment: load, construct, run SA, and RETURN results.\n",
    "    \"\"\"\n",
    "    \n",
    "    # Load instance\n",
    "    inst = load_capacitated_instance(json_path)\n",
    "    dist, tmat = build_distance_time_matrices(inst, rounding=\"auto\")\n",
    "    \n",
    "    # Apply K_modifier\n",
    "    K = inst.k + K_modifier\n",
    "    if K <= 0:\n",
    "        K = 1 # Need at least one vehicle\n",
    "    \n",
    "    # Parameters\n",
    "    hard_tw = True\n",
    "    f = 0.0\n",
    "    beta = 0.0\n",
    "    instance_name = os.path.basename(json_path)\n",
    "    \n",
    "    if verbose:\n",
    "        print(f\"\\n{'='*70}\")\n",
    "        print(f\"Running SA: {instance_name} | Alpha: {alpha} | Seed: {seed}\")\n",
    "        print(f\"Operators: {operator_set} | K: {K}\")\n",
    "        print(f\"{'='*70}\")\n",
    "    \n",
    "    # Set seed\n",
    "    np.random.seed(seed)\n",
    "    random.seed(seed) # Also set python's random seed for SA\n",
    "    \n",
    "    # Construct initial solution\n",
    "    start_construct = time.time()\n",
    "    initial_routes = greedy_profit_density(inst, dist, tmat, K, hard_tw, f, beta)\n",
    "    construct_time = time.time() - start_construct\n",
    "    \n",
    "    initial_obj = evaluate_solution(inst, initial_routes, dist, f, beta, hard_tw, alpha)\n",
    "    \n",
    "    # Run Simulated Annealing\n",
    "    sa = SimulatedAnnealing(inst, dist, tmat, hard_tw, f, beta, alpha, seed)\n",
    "    \n",
    "    # Pass the new parameters to the search method\n",
    "    final_routes, metrics = sa.search(\n",
    "        initial_routes, \n",
    "        max_time=max_time, \n",
    "        operator_set=operator_set,\n",
    "        T_start=T_start,\n",
    "        T_end=T_end,\n",
    "        alpha_cooling=alpha_cooling,\n",
    "        max_iter_per_temp=max_iter_per_temp,\n",
    "        verbose=verbose\n",
    "    )\n",
    "    \n",
    "    # --- Collect Final Results ---\n",
    "    final_obj = metrics.objective_history[-1] if metrics.objective_history else initial_obj\n",
    "    final_profit = sum(r.profit for r in final_routes)\n",
    "    final_distance = sum(r.cost for r in final_routes)\n",
    "    final_customers = metrics.customers_served_history[-1] if metrics.customers_served_history else 0\n",
    "    total_time = metrics.time_history[-1] if metrics.time_history else 0\n",
    "    total_iterations = metrics.iteration # SA iteration count is different\n",
    "    \n",
    "    if plot:\n",
    "        fig = plot_search_progress(metrics, f\"{instance_name} (SA)\")\n",
    "        # In a notebook, plt.show() is needed to display\n",
    "        plt.show()\n",
    "\n",
    "    results = {\n",
    "        'initial_obj': initial_obj,\n",
    "        'final_obj': final_obj,\n",
    "        'total_time': total_time,\n",
    "        'iterations': total_iterations,\n",
    "        'customers_served': final_customers,\n",
    "        'final_profit': final_profit,\n",
    "        'final_distance': final_distance,\n",
    "        'construction_time': construct_time,\n",
    "        # Add SA params for analysis\n",
    "        'T_start': T_start,\n",
    "        'alpha_cooling': alpha_cooling,\n",
    "        'max_iter_per_temp': max_iter_per_temp,\n",
    "    }\n",
    "    \n",
    "    return results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c0b382b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import glob\n",
    "import time\n",
    "import pandas as pd\n",
    "from tqdm import tqdm\n",
    "import itertools  # To help create all combinations\n",
    "\n",
    "# 1. Path\n",
    "BASE_DIR = os.getcwd()   # project root (when script is run from repo)\n",
    "# --- IMPORTANT ---\n",
    "# Create this folder and add your .json instance files\n",
    "BENCHMARK_FOLDER = os.path.join(BASE_DIR, \"benchmarks_cap_json\")\n",
    "\n",
    "# 2. Objective Function Params\n",
    "ALPHAS_TO_TEST = [0.1, 0.5]\n",
    "\n",
    "# 3. Statistical Params\n",
    "SEEDS_TO_TEST = [42, 123, 987]\n",
    "\n",
    "# 4. Neighborhood Params\n",
    "OPERATOR_SETS_TO_TEST = [\n",
    "    ('insert', 'relocate', 'swap', '2opt'), \n",
    "    ('insert', 'relocate', '2opt'),         \n",
    "    ('insert', 'relocate'),\n",
    "]\n",
    "\n",
    "# 5. Problem Params\n",
    "K_MODIFIERS_TO_TEST = [1, 3]\n",
    "\n",
    "# 6. SA Hyperparameters\n",
    "T_START_TO_TEST = [50.0, 100.0]\n",
    "ALPHA_COOLING_TO_TEST = [0.95, 0.99]\n",
    "MAX_ITER_PER_TEMP_TO_TEST = [200]\n",
    "T_END = 0.01\n",
    "\n",
    "# 7. Other settings\n",
    "MAX_TIME_PER_RUN = 60.0  # Shorter time for more experiments\n",
    "OUTPUT_CSV = \"experiment_results_SA_detailed.csv\"\n",
    "\n",
    "# ==================================================================\n",
    "\n",
    "def run_sa_experiments():\n",
    "    print(\"Starting TOPTW Simulated Annealing Experiment...\")\n",
    "    \n",
    "    # Check if benchmark folder exists\n",
    "    if not os.path.isdir(BENCHMARK_FOLDER):\n",
    "        print(f\"Error: Benchmark folder not found: '{BENCHMARK_FOLDER}'\")\n",
    "        print(\"Please create this folder and add your .json instance files to it.\")\n",
    "        return\n",
    "\n",
    "    instance_files = glob.glob(os.path.join(BENCHMARK_FOLDER, \"*.json\"))\n",
    "    if not instance_files:\n",
    "        print(f\"Error: No .json files found in '{BENCHMARK_FOLDER}'\")\n",
    "        print(\"Please add your .json instance files to this folder.\")\n",
    "        return\n",
    "\n",
    "    print(f\"Found {len(instance_files)} instances.\")\n",
    "    \n",
    "    # --- Create all experiment combinations ---\n",
    "    experiment_configs = list(itertools.product(\n",
    "        ALPHAS_TO_TEST,\n",
    "        SEEDS_TO_TEST,\n",
    "        OPERATOR_SETS_TO_TEST,\n",
    "        K_MODIFIERS_TO_TEST,\n",
    "        T_START_TO_TEST,\n",
    "        ALPHA_COOLING_TO_TEST,\n",
    "        MAX_ITER_PER_TEMP_TO_TEST\n",
    "    ))\n",
    "    \n",
    "    experiment_runs = []\n",
    "    for instance_path in instance_files:\n",
    "        for config in experiment_configs:\n",
    "            alpha, seed, op_set, k_mod, t_start, alpha_cool, iter_temp = config\n",
    "            experiment_runs.append({\n",
    "                'path': instance_path,\n",
    "                'alpha': alpha,\n",
    "                'seed': seed,\n",
    "                'op_set': op_set,\n",
    "                'k_mod': k_mod,\n",
    "                't_start': t_start,\n",
    "                'alpha_cool': alpha_cool,\n",
    "                'iter_temp': iter_temp\n",
    "            })\n",
    "\n",
    "    print(f\"Total experiments to run: {len(experiment_runs)}\")\n",
    "    \n",
    "    all_results = []\n",
    "    start_total_time = time.time()\n",
    "    \n",
    "    for run in tqdm(experiment_runs, desc=\"Running SA Experiments\"):\n",
    "        try:\n",
    "            # Pass all the new parameters to the worker function\n",
    "            result_dict = run_sa_experiment(\n",
    "                json_path=run['path'],\n",
    "                K_modifier=run['k_mod'],\n",
    "                seed=run['seed'],\n",
    "                max_time=MAX_TIME_PER_RUN,\n",
    "                alpha=run['alpha'],\n",
    "                operator_set=run['op_set'],\n",
    "                T_start=run['t_start'],\n",
    "                T_end=T_END,\n",
    "                alpha_cooling=run['alpha_cool'],\n",
    "                max_iter_per_temp=run['iter_temp'],\n",
    "                verbose=False,\n",
    "                plot=False\n",
    "            )\n",
    "            \n",
    "            # Add config back to results for the CSV\n",
    "            result_dict.update(run)\n",
    "            all_results.append(result_dict)\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"!!! ERROR running {os.path.basename(run['path'])} with {run['alpha']} !!!\")\n",
    "            print(f\"Error: {e}\\n\")\n",
    "\n",
    "    end_total_time = time.time()\n",
    "    print(f\"\\n\\n{'='*70}\")\n",
    "    print(f\"All experiments completed in {(end_total_time - start_total_time) / 60:.2f} minutes.\")\n",
    "    \n",
    "    if not all_results:\n",
    "        print(\"No results to analyze.\")\n",
    "        return\n",
    "\n",
    "    df = pd.DataFrame(all_results)\n",
    "    \n",
    "    # Save results\n",
    "    df.to_csv(OUTPUT_CSV, index=False)\n",
    "    print(f\"Results saved to '{OUTPUT_CSV}'\")\n",
    "    \n",
    "    # --- Updated Analysis ---\n",
    "    \n",
    "    print(\"\\n--- Operator Set Comparison (Averaged) ---\")\n",
    "    df['op_set_str'] = df['op_set'].astype(str)\n",
    "    op_set_summary = df.groupby('op_set_str')[['final_obj', 'total_time', 'iterations']].mean()\n",
    "    print(op_set_summary.sort_values('final_obj', ascending=False))\n",
    "    \n",
    "    print(\"\\n--- T_start Comparison (Averaged) ---\")\n",
    "    t_start_summary = df.groupby('T_start')[['final_obj', 'total_time', 'iterations']].mean()\n",
    "    print(t_start_summary.sort_values('final_obj', ascending=False))\n",
    "    \n",
    "    print(\"\\n--- Alpha (Cooling) Comparison (Averaged) ---\")\n",
    "    alpha_summary = df.groupby('alpha_cooling')[['final_obj', 'total_time', 'iterations']].mean()\n",
    "    print(alpha_summary.sort_values('final_obj', ascending=False))\n",
    "    \n",
    "    print(f\"\\n{'='*70}\")\n",
    "    print(f\"Analysis complete. Open '{OUTPUT_CSV}' for full details.\")\n",
    "\n",
    "# Run the new experiment script\n",
    "run_sa_experiments()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f436d16",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}